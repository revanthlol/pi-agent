// pi-agent/index.js - V4 with Pull-Based Polling
require('dotenv').config();
const io = require('socket.io-client');
const axios = require('axios');
const fs = require('fs');
const { exec } = require('child_process');
const path = require('path');
const PDFDocument = require('pdf-lib').PDFDocument;
const qrcode = require('qrcode-terminal');

// ==================== CONFIG ====================
const CLOUD_SERVER = process.env.CLOUD_URL || 'https://justpri.duckdns.org';
const PRINTER_NAME = process.env.PRINTER_NAME || 'auto';
const KIOSK_ID = process.env.KIOSK_ID || `kiosk_${require('os').hostname()}`;
const FRONTEND_URL = process.env.FRONTEND_URL || 'https://qr-wifi-printer.vercel.app';
const TEMP_DIR = './print-queue';
const HEARTBEAT_INTERVAL = 30000;
const POLL_INTERVAL = parseInt(process.env.POLL_INTERVAL) || 5000; // 5 seconds

// ==================== SETUP ====================
if (!fs.existsSync(TEMP_DIR)) fs.mkdirSync(TEMP_DIR);

console.log(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘   DirectPrint Agent V4 Starting...     â•‘
â•‘   Model: Pull-Based Polling            â•‘
â•‘   Kiosk ID: ${KIOSK_ID.padEnd(26)}â•‘
â•‘   Cloud: ${CLOUD_SERVER.padEnd(30)}â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
`);

// ==================== GENERATE QR CODE ====================
const qrUrl = `${FRONTEND_URL}?kiosk_id=${KIOSK_ID}`;

console.log('\nðŸ“± Scan this QR code to connect:\n');
qrcode.generate(qrUrl, { small: false });
console.log(`\nðŸ”— Or visit: ${qrUrl}\n`);

// ==================== SOCKET CONNECTION (for status updates only) ====================
const socket = io(CLOUD_SERVER, {
  reconnection: true,
  reconnectionDelay: 1000,
  reconnectionAttempts: Infinity
});

// ==================== STATE ====================
let currentJob = null;
let printerName = null;
const pendingJobs = new Map();
let isPolling = false;
let pollCount = 0;
let jobsFetchedToday = 0;
let lastPollTime = null;

// ==================== PRINTER DETECTION ====================
async function detectPrinter() {
  return new Promise((resolve, reject) => {
    if (PRINTER_NAME !== 'auto') {
      console.log(`âœ“ Using configured printer: ${PRINTER_NAME}`);
      return resolve(PRINTER_NAME);
    }

    exec('lpstat -p -d', (error, stdout, stderr) => {
      if (error) {
        console.error('âœ— CUPS not found. Install CUPS: sudo apt install cups');
        return reject('CUPS_NOT_INSTALLED');
      }

      const lines = stdout.split('\n');
      const defaultMatch = lines.find(l => l.startsWith('system default destination:'));
      
      if (defaultMatch) {
        const name = defaultMatch.split(':')[1].trim();
        console.log(`âœ“ Auto-detected printer: ${name}`);
        resolve(name);
      } else {
        const printerLine = lines.find(l => l.startsWith('printer'));
        if (printerLine) {
          const name = printerLine.split(' ')[1];
          console.log(`âœ“ Using first available: ${name}`);
          resolve(name);
        } else {
          console.warn('âš  No printer found');
          reject('NO_PRINTER_FOUND');
        }
      }
    });
  });
}

// ==================== PDF OPERATIONS ====================
async function countPDFPages(filePath) {
  try {
    const dataBuffer = fs.readFileSync(filePath);
    const pdfDoc = await PDFDocument.load(dataBuffer);
    return pdfDoc.getPageCount();
  } catch (e) {
    console.error('âš  Page count failed:', e.message);
    return 1;
  }
}

// ==================== POLLING FOR JOBS ====================
async function pollForJobs() {
  // Prevent concurrent polling
  if (isPolling) {
    return;
  }
  
  if (!socket.connected) {
    if (pollCount % 12 === 0) { // Log every minute
      console.log('âš  Not connected to cloud, skipping poll');
    }
    pollCount++;
    return;
  }
  
  isPolling = true;
  lastPollTime = new Date();
  
  try {
    const response = await axios.get(`${CLOUD_SERVER}/api/jobs/poll`, {
      params: { kiosk_id: KIOSK_ID },
      timeout: 10000
    });
    
    if (response.data.jobs && response.data.jobs.length > 0) {
      for (const job of response.data.jobs) {
        console.log(`[Poll] New job received: ${job.job_id}`);
        await handlePolledJob(job);
        jobsFetchedToday++;
      }
    } else {
      // Only log occasionally to avoid spam
      if (pollCount % 60 === 0) { // Every 5 minutes
        console.log(`[Poll] No jobs available (checked ${pollCount} times)`);
      }
    }
    
    pollCount++;
    
  } catch (error) {
    if (error.response?.status === 400) {
      console.error('[Poll] Bad request - check kiosk_id');
    } else if (error.code === 'ECONNREFUSED') {
      if (pollCount % 12 === 0) {
        console.error('[Poll] Cannot reach server');
      }
    } else if (error.response?.status !== 404) {
      console.error('[Poll] Error:', error.message);
    }
    pollCount++;
  } finally {
    isPolling = false;
  }
}

async function handlePolledJob(job) {
  const { job_id, filename, pages, file_data } = job;
  
  console.log(`ðŸ“„ Processing Job`);
  console.log(`   ID: ${job_id}`);
  console.log(`   File: ${filename}`);
  console.log(`   Pages: ${pages}`);
  
  const tempFile = path.join(TEMP_DIR, `${job_id}_${filename}`);
  
  try {
    // Decode base64 file data
    const fileBuffer = Buffer.from(file_data, 'base64');
    fs.writeFileSync(tempFile, fileBuffer);
    console.log('   âœ“ File saved locally');
    
    // Verify pages
    const actualPages = await countPDFPages(tempFile);
    console.log(`   âœ“ Verified: ${actualPages} pages`);
    
    // Add to local queue
    pendingJobs.set(job_id, {
      job_id,
      filename,
      pages: actualPages,
      filePath: tempFile,
      receivedAt: new Date()
    });
    
    // Execute immediately if not printing
    if (!currentJob) {
      executePrint(job_id);
    } else {
      console.log(`   â³ Queued (current job: ${currentJob})`);
    }
    
  } catch (e) {
    console.error('âœ— Job processing error:', e);
    
    // Report failure to server
    if (socket.connected) {
      socket.emit('print_complete', { 
        job_id,
        success: false,
        error: e.message 
      });
    }
    
    // Cleanup
    if (fs.existsSync(tempFile)) fs.unlinkSync(tempFile);
    pendingJobs.delete(job_id);
  }
}

async function executePrint(job_id) {
  const pending = pendingJobs.get(job_id);
  
  if (!pending) {
    console.error(`âœ— Job ${job_id} not found in pending queue`);
    return;
  }
  
  const { filename, filePath, pages } = pending;
  
  console.log(`\nðŸ–¨ï¸  Printing Job ${job_id}`);
  console.log(`   File: ${filename}`);
  
  currentJob = job_id;
  
  // Notify server: printing started
  if (socket.connected) {
    socket.emit('print_started', { job_id });
  }
  
  try {
    // Detect printer if not already done
    if (!printerName) {
      printerName = await detectPrinter();
    }
    
    // Send to CUPS
    const printCommand = `lp -d ${printerName} "${filePath}"`;
    
    exec(printCommand, (error, stdout, stderr) => {
      if (error) {
        console.error('âœ— Print failed:', stderr);
        
        if (socket.connected) {
          socket.emit('print_complete', { 
            job_id,
            success: false,
            error: stderr || error.message
          });
        }
      } else {
        console.log('âœ“ Print job sent to CUPS');
        console.log(stdout);
        
        if (socket.connected) {
          socket.emit('print_complete', { 
            job_id,
            success: true,
            pages_printed: pages
          });
        }
        
        console.log(`âœ“ Job ${job_id} completed\n`);
      }
      
      // Cleanup
      currentJob = null;
      pendingJobs.delete(job_id);
      
      setTimeout(() => {
        if (fs.existsSync(filePath)) {
          fs.unlinkSync(filePath);
          console.log(`   ðŸ—‘ï¸  Cleaned up temp file`);
        }
      }, 5000);
      
      // Check if more jobs are waiting
      if (pendingJobs.size > 0) {
        const nextJobId = pendingJobs.keys().next().value;
        console.log(`   â†’ Processing next job: ${nextJobId}`);
        executePrint(nextJobId);
      }
    });
    
  } catch (e) {
    console.error('âœ— Print execution error:', e);
    
    if (socket.connected) {
      socket.emit('print_complete', { 
        job_id,
        success: false,
        error: e.message
      });
    }
    
    currentJob = null;
    pendingJobs.delete(job_id);
  }
}

// ==================== SOCKET EVENTS (for status updates only) ====================
socket.on('connect', async () => {
  console.log('âœ“ Connected to Cloud Hub!');
  
  // Detect printer on startup
  try {
    printerName = await detectPrinter();
  } catch (e) {
    console.warn('âš  Could not detect printer:', e);
  }
  
  // Register with server
  socket.emit('register', { 
    kiosk_id: KIOSK_ID,
    hostname: require('os').hostname(),
    printer_name: printerName || 'unknown'
  });
  
  console.log('âœ“ Registered with cloud');
  console.log(`ðŸ”„ Polling enabled (every ${POLL_INTERVAL/1000}s)`);
  console.log('ðŸš€ Agent ready and listening for jobs!\n');
});

socket.on('disconnect', () => {
  console.log('âš  Disconnected from Cloud. Reconnecting...');
});

socket.on('reconnect', (attemptNumber) => {
  console.log(`âœ“ Reconnected after ${attemptNumber} attempts`);
});

socket.on('ping', () => {
  socket.emit('pong', { 
    status: 'alive', 
    uptime: process.uptime(),
    current_job: currentJob,
    pending_count: pendingJobs.size,
    poll_count: pollCount,
    jobs_fetched_today: jobsFetchedToday
  });
});

socket.on('update_config', (data) => {
  console.log('âš™ï¸  Config update received:', data);
});

// ==================== START POLLING ====================
setInterval(pollForJobs, POLL_INTERVAL);
console.log(`ðŸ“¡ Connecting to cloud...`);

// Initial poll after 2 seconds (after connection established)
setTimeout(() => {
  console.log('ðŸ”„ Starting job polling...');
  pollForJobs();
}, 2000);

// ==================== HEARTBEAT ====================
setInterval(() => {
  if (socket.connected) {
    socket.emit('heartbeat', {
      kiosk_id: KIOSK_ID,
      uptime: process.uptime(),
      printer_status: printerName ? 'ready' : 'no_printer',
      current_job: currentJob,
      pending_jobs: pendingJobs.size,
      memory: process.memoryUsage().heapUsed / 1024 / 1024,
      poll_count: pollCount,
      jobs_fetched_today: jobsFetchedToday,
      last_poll: lastPollTime
    });
  }
}, HEARTBEAT_INTERVAL);

// Status log
setInterval(() => {
  if (socket.connected) {
    console.log(`ðŸ’š Agent alive | Uptime: ${Math.floor(process.uptime())}s | Polls: ${pollCount} | Fetched: ${jobsFetchedToday} | Pending: ${pendingJobs.size}`);
  }
}, 60000);

// Reset daily counter at midnight
setInterval(() => {
  const now = new Date();
  if (now.getHours() === 0 && now.getMinutes() === 0) {
    jobsFetchedToday = 0;
    pollCount = 0;
    console.log('ðŸ“Š Daily counters reset');
  }
}, 60000);

// ==================== CLEANUP OLD FILES ====================
setInterval(() => {
  const now = Date.now();
  const files = fs.readdirSync(TEMP_DIR);
  
  files.forEach(file => {
    const filePath = path.join(TEMP_DIR, file);
    const stats = fs.statSync(filePath);
    const ageMinutes = (now - stats.mtimeMs) / 1000 / 60;
    
    if (ageMinutes > 30) {
      fs.unlinkSync(filePath);
      console.log(`ðŸ—‘ï¸  Cleaned up old file: ${file}`);
    }
  });
}, 300000);

// ==================== GRACEFUL SHUTDOWN ====================
process.on('SIGINT', () => {
  console.log('\nðŸ‘‹ Shutting down agent...');
  
  if (currentJob) {
    console.log(`âš  Warning: Job ${currentJob} was in progress`);
  }
  
  if (pendingJobs.size > 0) {
    console.log(`âš  Warning: ${pendingJobs.size} job(s) in queue`);
  }
  
  socket.disconnect();
  process.exit(0);
});

process.on('SIGTERM', () => {
  console.log('\nðŸ›‘ Received SIGTERM, shutting down...');
  socket.disconnect();
  process.exit(0);
});