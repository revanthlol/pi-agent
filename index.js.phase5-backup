// pi-agent/index.js - V5 with Document Conversion
require('dotenv').config();
const io = require('socket.io-client');
const axios = require('axios');
const fs = require('fs');
const { exec } = require('child_process');
const path = require('path');
const PDFDocument = require('pdf-lib').PDFDocument;
const qrcode = require('qrcode-terminal');

// ==================== CONFIG ====================
const CLOUD_SERVER = process.env.CLOUD_URL || 'https://justpri.duckdns.org';
const PRINTER_NAME = process.env.PRINTER_NAME || 'auto';
const KIOSK_ID = process.env.KIOSK_ID || `kiosk_${require('os').hostname()}`;
const FRONTEND_URL = process.env.FRONTEND_URL || 'https://qr-wifi-printer.vercel.app';
const TEMP_DIR = './print-queue';
const HEARTBEAT_INTERVAL = 30000;
const POLL_INTERVAL = parseInt(process.env.POLL_INTERVAL) || 5000;
const CONVERSION_TIMEOUT = 60000; // 60 seconds for conversion

// ==================== SETUP ====================
if (!fs.existsSync(TEMP_DIR)) fs.mkdirSync(TEMP_DIR);

console.log(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘   DirectPrint Agent V5 Starting...     â•‘
â•‘   Model: Pull-Based + Conversion       â•‘
â•‘   Kiosk ID: ${KIOSK_ID.padEnd(26)}â•‘
â•‘   Cloud: ${CLOUD_SERVER.padEnd(30)}â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
`);

// Check conversion tools on startup
checkConversionTools();

// ==================== GENERATE QR CODE ====================
const qrUrl = `${FRONTEND_URL}?kiosk_id=${KIOSK_ID}`;

console.log('\nðŸ“± Scan this QR code to connect:\n');
qrcode.generate(qrUrl, { small: false });
console.log(`\nðŸ”— Or visit: ${qrUrl}\n`);

// ==================== SOCKET CONNECTION ====================
const socket = io(CLOUD_SERVER, {
  reconnection: true,
  reconnectionDelay: 1000,
  reconnectionAttempts: Infinity
});

// ==================== STATE ====================
let currentJob = null;
let printerName = null;
const pendingJobs = new Map();
let isPolling = false;
let pollCount = 0;
let jobsFetchedToday = 0;
let conversionsToday = 0;
let lastPollTime = null;

// ==================== CONVERSION TOOLS CHECK ====================
function checkConversionTools() {
  console.log('ðŸ”§ Checking conversion tools...\n');
  
  // Check LibreOffice
  exec('libreoffice --version', (error, stdout) => {
    if (error) {
      console.warn('âš  LibreOffice not found - document conversion disabled');
      console.warn('   Install: sudo apt install libreoffice-writer libreoffice-core-nogui');
    } else {
      console.log(`âœ“ LibreOffice: ${stdout.trim()}`);
    }
  });
  
  // Check ImageMagick
  exec('convert --version', (error, stdout) => {
    if (error) {
      console.warn('âš  ImageMagick not found - image conversion disabled');
      console.warn('   Install: sudo apt install imagemagick');
    } else {
      const version = stdout.split('\n')[0];
      console.log(`âœ“ ImageMagick: ${version}`);
    }
  });
  
  console.log('');
}

// ==================== FILE TYPE DETECTION ====================
function getFileType(filename) {
  const ext = path.extname(filename).toLowerCase();
  
  if (ext === '.pdf') return 'pdf';
  if (['.doc', '.docx', '.rtf', '.odt', '.txt', '.md'].includes(ext)) return 'document';
  if (['.png', '.jpg', '.jpeg'].includes(ext)) return 'image';
  
  return 'unknown';
}

// ==================== DOCUMENT CONVERSION ====================
async function convertDocumentToPDF(inputPath) {
  return new Promise((resolve, reject) => {
    const outputDir = path.dirname(inputPath);
    const baseName = path.basename(inputPath, path.extname(inputPath));
    const outputPath = path.join(outputDir, `${baseName}.pdf`);
    
    console.log(`   ðŸ”„ Converting document to PDF...`);
    
    const cmd = `libreoffice --headless --convert-to pdf --outdir "${outputDir}" "${inputPath}"`;
    
    exec(cmd, { timeout: CONVERSION_TIMEOUT }, (error, stdout, stderr) => {
      if (error) {
        console.error(`   âœ— Conversion failed: ${stderr}`);
        reject(new Error(`LibreOffice conversion failed: ${stderr || error.message}`));
      } else {
        if (fs.existsSync(outputPath)) {
          console.log(`   âœ“ Converted to PDF`);
          resolve(outputPath);
        } else {
          reject(new Error('PDF output file not created'));
        }
      }
    });
  });
}

async function convertImageToPDF(inputPath) {
  return new Promise((resolve, reject) => {
    const outputPath = inputPath.replace(/\.(png|jpg|jpeg)$/i, '.pdf');
    
    console.log(`   ðŸ”„ Converting image to PDF...`);
    
    // Convert image to PDF, fit to A4 page
    const cmd = `convert "${inputPath}" -page A4 -gravity center "${outputPath}"`;
    
    exec(cmd, { timeout: CONVERSION_TIMEOUT }, (error, stdout, stderr) => {
      if (error) {
        console.error(`   âœ— Conversion failed: ${stderr}`);
        reject(new Error(`ImageMagick conversion failed: ${stderr || error.message}`));
      } else {
        if (fs.existsSync(outputPath)) {
          console.log(`   âœ“ Converted to PDF`);
          resolve(outputPath);
        } else {
          reject(new Error('PDF output file not created'));
        }
      }
    });
  });
}

// ==================== PRINTER DETECTION ====================
async function detectPrinter() {
  return new Promise((resolve, reject) => {
    if (PRINTER_NAME !== 'auto') {
      console.log(`âœ“ Using configured printer: ${PRINTER_NAME}`);
      return resolve(PRINTER_NAME);
    }

    exec('lpstat -p -d', (error, stdout, stderr) => {
      if (error) {
        console.error('âœ— CUPS not found. Install CUPS: sudo apt install cups');
        return reject('CUPS_NOT_INSTALLED');
      }

      const lines = stdout.split('\n');
      const defaultMatch = lines.find(l => l.startsWith('system default destination:'));
      
      if (defaultMatch) {
        const name = defaultMatch.split(':')[1].trim();
        console.log(`âœ“ Auto-detected printer: ${name}`);
        resolve(name);
      } else {
        const printerLine = lines.find(l => l.startsWith('printer'));
        if (printerLine) {
          const name = printerLine.split(' ')[1];
          console.log(`âœ“ Using first available: ${name}`);
          resolve(name);
        } else {
          console.warn('âš  No printer found');
          reject('NO_PRINTER_FOUND');
        }
      }
    });
  });
}

// ==================== PDF OPERATIONS ====================
async function countPDFPages(filePath) {
  try {
    const dataBuffer = fs.readFileSync(filePath);
    const pdfDoc = await PDFDocument.load(dataBuffer);
    return pdfDoc.getPageCount();
  } catch (e) {
    console.error('âš  Page count failed:', e.message);
    return 1;
  }
}

// ==================== POLLING FOR JOBS ====================
async function pollForJobs() {
  if (isPolling) return;
  
  if (!socket.connected) {
    if (pollCount % 12 === 0) {
      console.log('âš  Not connected to cloud, skipping poll');
    }
    pollCount++;
    return;
  }
  
  isPolling = true;
  lastPollTime = new Date();
  
  try {
    const response = await axios.get(`${CLOUD_SERVER}/api/jobs/poll`, {
      params: { kiosk_id: KIOSK_ID },
      timeout: 10000
    });
    
    if (response.data.jobs && response.data.jobs.length > 0) {
      for (const job of response.data.jobs) {
        console.log(`[Poll] New job received: ${job.job_id}`);
        await handlePolledJob(job);
        jobsFetchedToday++;
      }
    } else {
      if (pollCount % 60 === 0) {
        console.log(`[Poll] No jobs available (checked ${pollCount} times)`);
      }
    }
    
    pollCount++;
    
  } catch (error) {
    if (error.response?.status === 400) {
      console.error('[Poll] Bad request - check kiosk_id');
    } else if (error.code === 'ECONNREFUSED') {
      if (pollCount % 12 === 0) {
        console.error('[Poll] Cannot reach server');
      }
    } else if (error.response?.status !== 404) {
      console.error('[Poll] Error:', error.message);
    }
    pollCount++;
  } finally {
    isPolling = false;
  }
}

async function handlePolledJob(job) {
  const { job_id, filename, pages, file_data } = job;
  
  console.log(`ðŸ“„ Processing Job`);
  console.log(`   ID: ${job_id}`);
  console.log(`   File: ${filename}`);
  console.log(`   Pages: ${pages}`);
  
  const tempFile = path.join(TEMP_DIR, `${job_id}_${filename}`);
  
  try {
    // Decode and save file
    const fileBuffer = Buffer.from(file_data, 'base64');
    fs.writeFileSync(tempFile, fileBuffer);
    console.log('   âœ“ File saved locally');
    
    // Detect file type
    const fileType = getFileType(filename);
    console.log(`   ðŸ“‹ File type: ${fileType}`);
    
    let pdfPath = tempFile;
    
    // Convert to PDF if needed
    if (fileType === 'document') {
      try {
        pdfPath = await convertDocumentToPDF(tempFile);
        conversionsToday++;
      } catch (convError) {
        throw new Error(`Document conversion failed: ${convError.message}`);
      }
    } else if (fileType === 'image') {
      try {
        pdfPath = await convertImageToPDF(tempFile);
        conversionsToday++;
      } catch (convError) {
        throw new Error(`Image conversion failed: ${convError.message}`);
      }
    } else if (fileType === 'pdf') {
      console.log('   âœ“ PDF file, no conversion needed');
    } else {
      throw new Error(`Unsupported file type: ${path.extname(filename)}`);
    }
    
    // Verify and count pages
    const actualPages = await countPDFPages(pdfPath);
    console.log(`   âœ“ Verified: ${actualPages} pages`);
    
    // Add to local queue
    pendingJobs.set(job_id, {
      job_id,
      filename,
      pages: actualPages,
      filePath: pdfPath,
      originalPath: tempFile,
      receivedAt: new Date(),
      converted: pdfPath !== tempFile
    });
    
    // Execute immediately if not printing
    if (!currentJob) {
      executePrint(job_id);
    } else {
      console.log(`   â³ Queued (current job: ${currentJob})`);
    }
    
  } catch (e) {
    console.error('âœ— Job processing error:', e);
    
    if (socket.connected) {
      socket.emit('print_complete', { 
        job_id,
        success: false,
        error: e.message 
      });
    }
    
    // Cleanup
    if (fs.existsSync(tempFile)) fs.unlinkSync(tempFile);
    pendingJobs.delete(job_id);
  }
}

async function executePrint(job_id) {
  const pending = pendingJobs.get(job_id);
  
  if (!pending) {
    console.error(`âœ— Job ${job_id} not found in pending queue`);
    return;
  }
  
  const { filename, filePath, pages, originalPath, converted } = pending;
  
  console.log(`\nðŸ–¨ï¸  Printing Job ${job_id}`);
  console.log(`   File: ${filename}`);
  if (converted) {
    console.log(`   âœ“ Converted to PDF`);
  }
  
  currentJob = job_id;
  
  if (socket.connected) {
    socket.emit('print_started', { job_id });
  }
  
  try {
    if (!printerName) {
      printerName = await detectPrinter();
    }
    
    const printCommand = `lp -d ${printerName} "${filePath}"`;
    
    exec(printCommand, (error, stdout, stderr) => {
      if (error) {
        console.error('âœ— Print failed:', stderr);
        
        if (socket.connected) {
          socket.emit('print_complete', { 
            job_id,
            success: false,
            error: stderr || error.message
          });
        }
      } else {
        console.log('âœ“ Print job sent to CUPS');
        console.log(stdout);
        
        if (socket.connected) {
          socket.emit('print_complete', { 
            job_id,
            success: true,
            pages_printed: pages
          });
        }
        
        console.log(`âœ“ Job ${job_id} completed\n`);
      }
      
      // Cleanup
      currentJob = null;
      pendingJobs.delete(job_id);
      
      setTimeout(() => {
        // Delete both original and converted files
        if (fs.existsSync(filePath)) fs.unlinkSync(filePath);
        if (originalPath && originalPath !== filePath && fs.existsSync(originalPath)) {
          fs.unlinkSync(originalPath);
        }
        console.log(`   ðŸ—‘ï¸  Cleaned up temp files`);
      }, 5000);
      
      // Check if more jobs are waiting
      if (pendingJobs.size > 0) {
        const nextJobId = pendingJobs.keys().next().value;
        console.log(`   â†’ Processing next job: ${nextJobId}`);
        executePrint(nextJobId);
      }
    });
    
  } catch (e) {
    console.error('âœ— Print execution error:', e);
    
    if (socket.connected) {
      socket.emit('print_complete', { 
        job_id,
        success: false,
        error: e.message
      });
    }
    
    currentJob = null;
    pendingJobs.delete(job_id);
  }
}

// ==================== SOCKET EVENTS ====================
socket.on('connect', async () => {
  console.log('âœ“ Connected to Cloud Hub!');
  
  try {
    printerName = await detectPrinter();
  } catch (e) {
    console.warn('âš  Could not detect printer:', e);
  }
  
  socket.emit('register', { 
    kiosk_id: KIOSK_ID,
    hostname: require('os').hostname(),
    printer_name: printerName || 'unknown'
  });
  
  console.log('âœ“ Registered with cloud');
  console.log(`ðŸ”„ Polling enabled (every ${POLL_INTERVAL/1000}s)`);
  console.log('ðŸš€ Agent ready and listening for jobs!\n');
});

socket.on('disconnect', () => {
  console.log('âš  Disconnected from Cloud. Reconnecting...');
});

socket.on('reconnect', (attemptNumber) => {
  console.log(`âœ“ Reconnected after ${attemptNumber} attempts`);
});

socket.on('ping', () => {
  socket.emit('pong', { 
    status: 'alive', 
    uptime: process.uptime(),
    current_job: currentJob,
    pending_count: pendingJobs.size,
    poll_count: pollCount,
    jobs_fetched_today: jobsFetchedToday,
    conversions_today: conversionsToday
  });
});

socket.on('update_config', (data) => {
  console.log('âš™ï¸  Config update received:', data);
});

// ==================== START POLLING ====================
setInterval(pollForJobs, POLL_INTERVAL);
console.log(`ðŸ“¡ Connecting to cloud...`);

setTimeout(() => {
  console.log('ðŸ”„ Starting job polling...');
  pollForJobs();
}, 2000);

// ==================== HEARTBEAT ====================
setInterval(() => {
  if (socket.connected) {
    socket.emit('heartbeat', {
      kiosk_id: KIOSK_ID,
      uptime: process.uptime(),
      printer_status: printerName ? 'ready' : 'no_printer',
      current_job: currentJob,
      pending_jobs: pendingJobs.size,
      memory: process.memoryUsage().heapUsed / 1024 / 1024,
      poll_count: pollCount,
      jobs_fetched_today: jobsFetchedToday,
      conversions_today: conversionsToday,
      last_poll: lastPollTime
    });
  }
}, HEARTBEAT_INTERVAL);

// Status log
setInterval(() => {
  if (socket.connected) {
    console.log(`ðŸ’š Agent alive | Uptime: ${Math.floor(process.uptime())}s | Polls: ${pollCount} | Fetched: ${jobsFetchedToday} | Conversions: ${conversionsToday} | Pending: ${pendingJobs.size}`);
  }
}, 60000);

// Reset daily counter at midnight
setInterval(() => {
  const now = new Date();
  if (now.getHours() === 0 && now.getMinutes() === 0) {
    jobsFetchedToday = 0;
    conversionsToday = 0;
    pollCount = 0;
    console.log('ðŸ“Š Daily counters reset');
  }
}, 60000);

// ==================== CLEANUP OLD FILES ====================
setInterval(() => {
  const now = Date.now();
  const files = fs.readdirSync(TEMP_DIR);
  
  files.forEach(file => {
    const filePath = path.join(TEMP_DIR, file);
    try {
      const stats = fs.statSync(filePath);
      const ageMinutes = (now - stats.mtimeMs) / 1000 / 60;
      
      if (ageMinutes > 30) {
        fs.unlinkSync(filePath);
        console.log(`ðŸ—‘ï¸  Cleaned up old file: ${file}`);
      }
    } catch (e) {
      // File might have been deleted already
    }
  });
}, 300000);

// ==================== GRACEFUL SHUTDOWN ====================
process.on('SIGINT', () => {
  console.log('\nðŸ‘‹ Shutting down agent...');
  
  if (currentJob) {
    console.log(`âš  Warning: Job ${currentJob} was in progress`);
  }
  
  if (pendingJobs.size > 0) {
    console.log(`âš  Warning: ${pendingJobs.size} job(s) in queue`);
  }
  
  socket.disconnect();
  process.exit(0);
});

process.on('SIGTERM', () => {
  console.log('\nðŸ›‘ Received SIGTERM, shutting down...');
  socket.disconnect();
  process.exit(0);
});
